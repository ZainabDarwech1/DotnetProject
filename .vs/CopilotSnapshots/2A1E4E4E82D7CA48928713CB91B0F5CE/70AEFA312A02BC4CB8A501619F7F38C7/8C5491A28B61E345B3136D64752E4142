using Domain.Entities;
using Domain.Enums;
using Domain.Interfaces;
using LebAssist.Application.DTOs;
using LebAssist.Application.Interfaces;
using Microsoft.Extensions.Logging;
using ProviderServiceEntity = Domain.Entities.ProviderService;

namespace LebAssist.Application.Services
{
    public class ProviderService : IProviderService
    {
        private readonly IUnitOfWork _unitOfWork;
        private readonly IFileStorageService _fileStorageService;
        private readonly ILogger<ProviderService> _logger;

        public ProviderService(
            IUnitOfWork unitOfWork,
            IFileStorageService fileStorageService,
            ILogger<ProviderService> logger)
        {
            _unitOfWork = unitOfWork;
            _fileStorageService = fileStorageService;
            _logger = logger;
        }

        public async Task<IEnumerable<ProviderServiceDto>> GetProviderServicesAsync(int clientId)
        {
            var providerServices = await _unitOfWork.ProviderServices.GetAllAsync();

            return providerServices
                .Where(ps => ps.ClientId == clientId)
                .Select(ps => new ProviderServiceDto
                {
                    ProviderServiceId = ps.ProviderServiceId,
                    ServiceId = ps.ServiceId,
                    ServiceName = ps.Service.ServiceName,
                    CategoryName = ps.Service.Category.CategoryName,
                    IsActive = ps.IsActive,
                    PricePerHour = ps.PricePerHour,
                    DateAdded = ps.DateAdded
                });
        }

        public async Task<bool> AddProviderServiceAsync(int clientId, AddProviderServiceDto dto)
        {
            try
            {
                var client = await _unitOfWork.Clients.GetByIdAsync(clientId);
                if (client == null || !client.IsProvider)
                {
                    _logger.LogWarning("Client {ClientId} is not a provider", clientId);
                    return false;
                }

                var service = await _unitOfWork.Services.GetByIdAsync(dto.ServiceId);
                if (service == null)
                {
                    _logger.LogWarning("Service {ServiceId} not found", dto.ServiceId);
                    return false;
                }

                var existingServices = await _unitOfWork.ProviderServices.GetAllAsync();
                if (existingServices.Any(ps => ps.ClientId == clientId && ps.ServiceId == dto.ServiceId))
                {
                    _logger.LogWarning("Provider {ClientId} already offers service {ServiceId}", clientId, dto.ServiceId);
                    return false;
                }

                var providerService = new ProviderServiceEntity
                {
                    ClientId = clientId,
                    ServiceId = dto.ServiceId,
                    IsActive = true,
                    DateAdded = DateTime.UtcNow,
                    PricePerHour = dto.PricePerHour
                };

                await _unitOfWork.ProviderServices.AddAsync(providerService);
                await _unitOfWork.SaveChangesAsync();

                _logger.LogInformation("Provider service added for client {ClientId}, service {ServiceId}", clientId, dto.ServiceId);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding provider service for client {ClientId}", clientId);
                return false;
            }
        }

        public async Task<bool> RemoveProviderServiceAsync(int clientId, int serviceId)
        {
            try
            {
                var providerServices = await _unitOfWork.ProviderServices.GetAllAsync();
                var providerService = providerServices.FirstOrDefault(ps => ps.ClientId == clientId && ps.ServiceId == serviceId);

                if (providerService == null)
                    return false;

                var bookings = await _unitOfWork.Bookings.GetAllAsync();
                var hasActiveBookings = bookings.Any(b =>
                    b.ProviderId == clientId &&
                    b.ServiceId == serviceId &&
                    (b.Status == BookingStatus.Pending || b.Status == BookingStatus.Accepted || b.Status == BookingStatus.InProgress));

                if (hasActiveBookings)
                {
                    _logger.LogWarning("Cannot remove service {ServiceId} for provider {ClientId} - active bookings exist", serviceId, clientId);
                    return false;
                }

                await _unitOfWork.ProviderServices.DeleteAsync(providerService.ProviderServiceId);
                await _unitOfWork.SaveChangesAsync();

                _logger.LogInformation("Provider service removed for client {ClientId}, service {ServiceId}", clientId, serviceId);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error removing provider service for client {ClientId}", clientId);
                return false;
            }
        }

        public async Task<bool> UpdateProviderServicePriceAsync(int clientId, int serviceId, decimal pricePerHour)
        {
            try
            {
                var providerServices = await _unitOfWork.ProviderServices.GetAllAsync();
                var providerService = providerServices.FirstOrDefault(ps => ps.ClientId == clientId && ps.ServiceId == serviceId);

                if (providerService == null)
                    return false;

                providerService.PricePerHour = pricePerHour;
                await _unitOfWork.ProviderServices.UpdateAsync(providerService);
                await _unitOfWork.SaveChangesAsync();

                _logger.LogInformation("Provider service price updated for client {ClientId}, service {ServiceId}", clientId, serviceId);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating provider service price for client {ClientId}", clientId);
                return false;
            }
        }

        public async Task<IEnumerable<PortfolioPhotoDto>> GetProviderPortfolioAsync(int clientId)
        {
            var portfolios = await _unitOfWork.Repository<ProviderPortfolio>().GetAllAsync();

            return portfolios
                .Where(p => p.ClientId == clientId)
                .OrderBy(p => p.DisplayOrder)
                .ThenByDescending(p => p.UploadDate)
                .Select(p => new PortfolioPhotoDto
                {
                    PortfolioPhotoId = p.PortfolioPhotoId,
                    PhotoPath = p.PhotoPath,
                    Caption = p.Caption,
                    UploadDate = p.UploadDate,
                    DisplayOrder = p.DisplayOrder
                });
        }

        public async Task<int> AddPortfolioPhotoAsync(int clientId, byte[] photoData, string fileName, string? caption)
        {
            try
            {
                if (!_fileStorageService.ValidateImageFile(fileName, photoData.Length))
                {
                    _logger.LogWarning("Invalid portfolio photo file for client {ClientId}", clientId);
                    return 0;
                }

                var photoPath = await _fileStorageService.SaveFileAsync(photoData, fileName, "portfolios");
                if (photoPath == null)
                    return 0;

                var portfolios = await _unitOfWork.Repository<ProviderPortfolio>().GetAllAsync();
                var maxOrder = portfolios.Where(p => p.ClientId == clientId).Max(p => (int?)p.DisplayOrder) ?? 0;

                var portfolio = new ProviderPortfolio
                {
                    ClientId = clientId,
                    PhotoPath = photoPath,
                    Caption = caption,
                    UploadDate = DateTime.UtcNow,
                    DisplayOrder = maxOrder + 1
                };

                await _unitOfWork.Repository<ProviderPortfolio>().AddAsync(portfolio);
                await _unitOfWork.SaveChangesAsync();

                _logger.LogInformation("Portfolio photo added for client {ClientId}", clientId);
                return portfolio.PortfolioPhotoId;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding portfolio photo for client {ClientId}", clientId);
                return 0;
            }
        }

        public async Task<bool> DeletePortfolioPhotoAsync(int clientId, int portfolioPhotoId)
        {
            try
            {
                var portfolio = await _unitOfWork.Repository<ProviderPortfolio>().GetByIdAsync(portfolioPhotoId);
                if (portfolio == null || portfolio.ClientId != clientId)
                    return false;

                await _fileStorageService.DeleteFileAsync(portfolio.PhotoPath);

                await _unitOfWork.Repository<ProviderPortfolio>().DeleteAsync(portfolioPhotoId);
                await _unitOfWork.SaveChangesAsync();

                _logger.LogInformation("Portfolio photo {PhotoId} deleted for client {ClientId}", portfolioPhotoId, clientId);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting portfolio photo {PhotoId} for client {ClientId}", portfolioPhotoId, clientId);
                return false;
            }
        }

        public async Task<bool> ReorderPortfolioPhotosAsync(int clientId, List<int> photoIds)
        {
            try
            {
                var portfolios = await _unitOfWork.Repository<ProviderPortfolio>().GetAllAsync();
                var clientPortfolios = portfolios.Where(p => p.ClientId == clientId).ToList();

                for (int i = 0; i < photoIds.Count; i++)
                {
                    var portfolio = clientPortfolios.FirstOrDefault(p => p.PortfolioPhotoId == photoIds[i]);
                    if (portfolio != null)
                    {
                        portfolio.DisplayOrder = i + 1;
                        await _unitOfWork.Repository<ProviderPortfolio>().UpdateAsync(portfolio);
                    }
                }

                await _unitOfWork.SaveChangesAsync();

                _logger.LogInformation("Portfolio photos reordered for client {ClientId}", clientId);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error reordering portfolio photos for client {ClientId}", clientId);
                return false;
            }
        }
    }
}
